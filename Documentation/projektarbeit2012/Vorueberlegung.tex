\label{sec:Vorueberlegung}

\textbf{Time To Live}

Die TTL bezeichnet die Lebensdauer eines Datenpakets und ist dabei von
unterschiedlichen Aspekten abh{\"a}ngig. So kann ein Paket einerseits nach
Ablauf eines Zeitraums oder nach einer bestimmten Anzahl
von hops verworfen werden. Das Ablaufen durch den hop \todo {erklären was hop
ist} count ist dabei in einem Szenario der interplanetaren Kommunikation derzeit
eher unrealistisch, da zumeist eine Punkt-zu-Punkt Verbindung anvisiert
wird (kein intensives Routing {\"u}ber eine Vielzahl an Stationen). Somit w{\"a}re unter Ber{\"u}cksichtigung einer
interplanetaren Kommunikation eine TTL Realisierung per Zeitstempel
sinnvoller, da hier{\"u}ber unrealistische {\"U}bertragungszeiten einfach
erkannt werden k{\"o}nnen (unter Ber{\"u}cksichtigung des {\"U}bertragungskontextes).
Aufgrund der beschr{\"a}nkten Ressourcen unter interplanetaren
Kommunikationsumgebungen ist die Frage nach der Vorhaltedauer (Speicherung der
Daten auf Seiten des extraterrestrischen Senders z.B. in einer Sendqueue) von
entscheidender Bedeutung.
Eine m{\"o}gliche Entscheidungsgrundlage daf{\"u}r, wann Daten aus einer
Sendqueue verworfen werden sollen, w{\"a}re die Wichtigkeit selbiger. So
k{\"o}nnen Daten geringer Relevanz direkt nach dem Senden gel{\"o}scht werden,
wohingegen Daten hoher Relevanz erst nach Empfangsquittierung bzw. Ablauf des
TTL Timers verworfen werden.
\todo{wir hatten glaub ich schon ein erstes konzept/ideen zur umsetzung}

\newpage %Damit die {\"U}berschrift auf der n{\"a}chsten seite erscheint
\textbf{Protocol Stack}

Die von der jeweiligen Anwendung an den CROP Stack {\"u}bergebenen Daten werden
zun{\"a}chst in kleinere Datenbl{\"o}cke gesplittet. Diese Datenbl{\"o}cke
werden der Relevanz nach evaluiert und anschlie{\ss}end priorisiert.
Im Anschlu{\ss} daran werden die priorisierten Datenbl{\"o}cke der jeweiligen
Wertigkeit in einer Queue gespeichert. Anschlie{\ss}end werden im
Packetizer die Datenbl{\"o}cke h{\"o}chster Priorit{\"a}t zu einer Message zusammengefasst
die danach an den UDP Stack {\"u}bergeben werden kann.

\begin{figure}[H]
\centering
\includegraphics[scale=.25]{CRODT.pdf}
\caption{Das CRODT Framework}
\label{fig:CRODT}
\end{figure}

Die Abbildung \ref{fig:OSI_Stack} \todo{quelle} zeigt die Schachtelung von Daten
innerhalb des OSI-Stacks. Dabei wird das Weiterreichen der Daten an die jeweils n{\"a}chste
Schicht des Stacks verdeutlicht. In jedem dieser Schritte wird dem neuen
Datenpaket der Header der aktuellen Schicht angeh{\"a}ngt und somit das
weitergereichte Datenpaket um notwendige {\"U}bersetzungsinformationen f{\"u}r
den Empf{\"a}nger erweitert. Auf der Empf{\"a}ngerseite erfolgt eine Invertierung dieses
Vorganges. Die Abbildung \ref{fig:CROP_Stack} zeigt die Handhabung im CROP-Stack
unter Nutzung des UDP-Protokolls f{\"u}r die finale Daten{\"u}bertragung. Die Layer
7,6,5 des OSI Modells (Application, Presentation und Session Layer) werden
hierbei vereinfacht als Anwendungsschicht zusammengefasst und bezeichnet. Der
Transport Layer des OSI Modells entspricht der Transportschicht des
vereinfachten Modells, die Internet Schicht repr{\"a}sentiert den Network Layer.
Der Data Link Layer und der Physical Layer des OSI-Modells werden zur
Netzzugangsschicht zusammengefasst. Dem OSI-Modell entsprechend wird eine
equivalente Darstellung der Paketerweiterung (um den jeweiligen Header)
aufgef{\"u}hrt. Der Protokollablauf sieht dabei nach Aufteilung der Daten in Bl{\"o}cke
und Zuweisung einer Priorit{\"a}t (Datenbl{\"o}cke mit Datenblock-Header), eine
Zusammenfassung zu einer Nachricht mit ausschließlich höher priorisierten
Daten vor (Paket aus mehreren Datenbl{\"o}cken um einen Message-Header erweitert). Dieses Datenpaket
wird nun an den UDP-Stack weitergegeben (Daten um UDP-Header erweitert). Werden
anschlie{\ss}end Adressiert (erweitert um IP-Header) und dann entsprechend der
{\"U}bertragungsschnittstelle und deren Protokoll versandt. \todo{durch die 100
extra klammern und schachtelsätz sehr schwer zu lesen und zu verstehen}

\begin{figure}[H]
\centering
\includegraphics[scale=.5]{OSI_Stack.pdf}
\caption{Der OSI Stack}
\label{fig:OSI_Stack}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[scale=.5]{CROP_Stack.pdf}
\caption{Der CROP Stack}
\label{fig:CROP_Stack}
\end{figure}

\textbf{Error Correction Code}

Zur Fehlererkennung bzw. -korrektur wird ein CRC-Code verwendet. Dieser wird
innerhalb des Protokolls abhängig der Paketgr{\"o}{\ss}e auf CRC 16 Bit oder
CRC 32 Bit eingestellt. Die Pr{\"u}fsumme wird durch einen mathematischen
Algorithmus ermittelt und dann mit dem Paket {\"u}bertragen. Wenn der
Empf{\"a}nger die R{\"u}ckrechnung unter Einbeziehnung der Pr{\"u}fsumme
vornimmt, kann anhand des Ergebnisses ermittelt werden, ob das Paket
verf{\"a}lscht wurde. Die Berechnung einer Checksumme funktioniert dabei wie
folgt:

Das zu {\"u}bertragende Datenframe sei exemplarisch gegeben als: 11 0101 1011.
Desweiteren wird ein CRC-Generatorpolynom ben{\"o}tigt, welches im Beispiel als
$G(x) = x^4 + x + 1$ gegeben sei. Die daraus resultierende Schreibweise in Generatorbits lautet: 10011
($1*x^4+0*x^3+0*x^2+1*x^1+1*x^0$).
Anschließend wird eine erweiterte Darstellung des zu {\"u}bertragenden Frames
erzeugt, woraus der folgende Ausdruck hervorgeht: 11 0101 1011 0000
(Frame-0-Bits; Erweiterung des Datenframes um die Ordnung des Generatorpolynoms
in Nullen). Danach erfolgt eine Division des erweiterten Frames durch das
Generatorpolynom.

\makeatletter
\def\cline#1{\noalign{\vskip-2ex}\@cline#1\@nil}
\makeatother

\begin{figure}[H]
\jot-0.6mm
\begin{alignat*}{14}
1&1&0&1&0&1&1&0&1&1&0&0&0&0& : 10011=1100001010 \\
1&0&0&1&1\\ \cline{1-5}
&1&0&0&1&1& \\ 
&1&0&0&1&1& \\ \cline{2-6}
&&0&0&0&0&1& \\ 
&&1&0&0&1&1& \\ \cline{3-7}
&&&0&0&0&1&0& \\                                                 
&&&1&0&0&1&1& \\ \cline{4-8}
&&&&0&0&1&0&1& \\                                               
&&&&1&0&0&1&1& \\ \cline{5-9}
&&&&&0&1&0&1&1& \\                                           
&&&&&1&0&0&1&1&  \\ \cline{6-10}                                                                                  
&&&&&&1&0&1&1&0& \\                                           
&&&&&&1&0&0&1&1& \\   \cline{7-11}                                                                                      
&&&&&&&0&1&0&1&0& \\                                         
&&&&&&&1&0&0&1&1& \\ \cline{8-12}                                                                                     
&&&&&&&&1&0&1&0&0& \\                                       
&&&&&&&&1&0&0&1&1& \\ \cline{9-13}                                                                               
&&&&&&&&&0&1&1&1&0& \\                                     
&&&&&&&&&1&0&0&1&1& \\ \cline{10-14}    
&&&&&&&&&&1&1&1&0& 
\end{alignat*}
\end{figure}

Das Ergebnis dieser Modulo-2-Division (der Rest in Zahlen: 1110) wird an das
urspr{\"u}nglich zu {\"u}bertragende Frame (11 0101 1011) angeh{\"a}ngt. Somit ergibt sich
das Frame inklusive Pr{\"u}fsumme: 11 0101 1011 1110. Der
Empf{\"a}nger kann damit {\"u}berpr{\"u}fen, ob das Frame korrekt {\"u}bertragen
wurde. Dazu wird dieses durch das Generatorpolynom (Generatorbits) geteilt.
Das Ergebnis muss dabei null sein. Das im Beispiel genutzte Polynom kann mit der
Ordnung 4 ($2^4=16$) auf 16 Bits an Daten angewandt werden. Das Polynom $x16+x12+x5+1$
wird hingegen beispielsweise beim CRC-CCITT 16 Bit-Verfahren genutzt und
kann auf Datenframes bis zu einer Gr{\"o}{\ss}e von $2^{16}=65536 Bit$
angewendet werden (Polynom eines 32 Bit CRC entsprechend mit Ordnung 32) (Ref.
\cite{web2}).

