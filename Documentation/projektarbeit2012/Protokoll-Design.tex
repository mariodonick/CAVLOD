\label{sec:ProtokolDesign}Eine zentrale Rolle bei der Entwicklung des Aufbaus und der Strukturierungspielte der Nachrichtenheader.Dieser beinhaltet Informationen, die zum eindeutigen Versenden und Identifizieren dermitgelieferten Daten notwendig sind. Dazu gehören die Versionsnummer,die Konfiguration, die Länge der Nachricht und die genauen Adressendes Senders und Empfängers. Neben dem Header sind die verpackten Daten, dersogenannte Payload, und ein CRC-Code zur Fehlerüberprüfung der Nachrichtvorhanden. In Abbildung \ref{fig:DatenaufschluesselungMessage} ist der Headereiner Nachricht im Detail dargestellt.\begin{figure}[H]	\centering	\includegraphics[width=\textwidth]{DatenaufschluesselungMessage.pdf}	\caption{Datenaufschlüsselung der Nachricht}	\label{fig:DatenaufschluesselungMessage}\end{figure}Die Versionsnummer belegt die ersten vier Bits des Headers. Diesesignalisiert dem Empfänger mit welcher Version des Protokolls die Nachrichtverpackt und versandt wurde. Danach folgt die Konfiguration. Mit Hilfe dieser,können Einstellungen vorgenommen werden, welche die Größe der gesamten Nachrichtbeeinflussen. Somit ist in speziellen Fällen eine bandbreitenschonendeÜbertragung der Nachricht möglich, da keine ungenutzten Informationen oder Bitsvorhanden sind. Für die Konfiguration wurden $12$ Bits reserviert. Die ersten drei Bitsbestimmen das Adressformat. Dieses ermöglicht das Aufsetzen des Protokolls aufbereits bestehenden Standards, wie IPv6 oder das Bundle-Protokoll.Die verbleibenden neun Bits sind für zusätzliche Einstellungsmöglichkeiten zur Erweiterung desProtokolls reserviert. Die Bitvergabe der Adressen von Sender und Empfängererfolgt dynamisch abhängig der Konfiguration.Dies ist für die Nutzung unterschiedlicher Übertragungsprotkolle notwendig.Für IPv6 werden $256$ Bit bereitgestellt. Dies sind jeweils $128$ Bit fürdie Sender- und Empfängeradresse. Die Länge repräsentiert die Größe der gesamtenNachricht in Bytes und belegt die nächsten $24$ Bits.Der vorletzte Bestandteil der Nachricht, der sogenannte Payload, beinhaltet dieeigentlich Daten und besteht aus mehreren Datenblöcken. Zusätzlich werden amEnde die Prüfsummenbits zur Fehlererkennung hinzugefügt. Diese sind $16$ Bits lang,wenn die Gesamtlänge der Nachricht kleiner gleich $2^{16}$ Bytes beträgt.Andernfalls beträgt die Länge $32$ Bits. Durch diese Unterteilung kannOverhead vermieden werden und trotzdem ist gewährleistet große Nachrichtenverschicken zu können.\begin{figure}[H]	\centering	\includegraphics[width=\textwidth]{DatenaufschluesselungDB.pdf}	\caption{Aufschlüsselung der Datenblöcke}  \label{fig:DatenaufschluesselungDB}\end{figure}Eine schnelle und eindeutige Zuordnung eines einzelnen Datenblockes auf derEmpfängerseite,  \todo{silbentrennung}stand bei der Entwicklung des Headers imMittelpunkt.Das heißt neben der Bitvergabe war eine genaue Überlegung über die richtige Reihenfolgenotwendig. Hierzu gibt es drei Ansätze, welche in Abbildung\ref{fig:DatenblockVarianten} dargestellt sind.\begin{figure}[H]	\centering	\includegraphics[width=\textwidth]{DatenblockVarianten.pdf}	\caption{Ansätze des Datenblockheaders}  \label{fig:DatenblockVarianten}\end{figure}Ein Datenblock besteht aus den folgenden Teilen: DOID \todo{glossar}(Data ObjectIdentification Number), Datentyp, Konfiguration, Sequenznummer und der Länge desDatenblocks. Die DOID repräsentiert die Datei (Bild, Text, Sensorwerte,\etc)dem der Datenblock angehört. Das Differenzieren der einzelnen Datenblöckeuntereinander erfolgt mittels der Sequenznummer. Durch die Einführung einesDatentyps im Header wird der Bereich der DOID indirekt vergrößert. Diesist aufgrund der eindeutigen Zuordnung einer DOID zu einem Datentyp möglich.\newlineAusgegangen wurde anfangs von je acht Bit für Datentyp und Konfiguration.In diesem Zusammenhang wurde hinterfragt, ob die Bitvergabe ausreicht,weil sehr viele verschiedene Datentypen und Formate existieren. Infolgedessenwurde, wie in Variante $1$ zu sehen, ein zusätzliches Byte zur Verfügunggestellt. Aufgeteilt zu zwei Bit für den Datentyp und sechs Bit für dieKonfiguration. Die Idee hinter dieser Variante war, dass der Datenblock alserstes über die DOID und im Folgenden dem zugeordneten Datentyp identifiziertwird. Anschließend sollte die Konfiguration und die Sequenznummer folge.Ein ähnlicher Aufbau gilt ebenfalls für Möglichkeit $2$, bei der die restlichensechs Bit zur Vorreservierung größerer Datentypen genutzt wurden. Dies warbezüglich des Datentyps und der Menge unterschiedlicher Datenblöcke die bessereVariante. Eine effektivere Maßnahme ergab sich am Ende nicht aus demSpendieren eines zusätzlichen Bytes, sondern aus einer anderen Reihenfolge inder die Bestandteile im Header angeordnet sind. Wie in Variante $3$ ersichtlich,wurden sechs Bit gespart. Dadurch wird zuerst jeder Datenblock anhandseines Datentypes identifiziert und anschliessend durch die DOID und dieSequenznummer spezifiziert. Danach folgt die Konfiguration mit $6$ Bits.Dabei sind die vordersten drei Bits die Kompression des Datenblockheaders, damitkann die Längen der DOID, der SequenzNummer und der Länge des gesamtenDatenblockes varriert. Dadurch können auch kompakte Blöcke effizient verschicktwerden.Das vierte Bit gibt an, ob ein Zeitstempel nach dem Header und vor einemDatenpacket mit einer Länge von $8$ Byte gesetzt wird.Dieses Bit wurde in der Konfiguration eingeführt, weil bei einigen Datentypennicht zwingend eine Zeitangabe benötigt wird und somit Overhead vermiedenwerden kann. Für Daten mit konstanter aber geringer Größe können mehrere Wertegleichzeitig in einem Datenblock platziert werden. Diese besitzen beigesetztem Zeitbit eine eigene Zeitangabe. Die Abbildung\ref{fig:uebersichtdatenaufschlüsselung} stellt diesen Sachverhalt noch einmalübersichtlich dar.\begin{figure}[H]  \centering  \includegraphics[width=\textwidth]{Datenaufschluesselung.pdf}  \caption{Übersicht der Datenaufschlüsselung}  \label{fig:uebersichtdatenaufschlüsselung}\end{figure}Die Abbildung \ref{fig:beispielJPG} zeigt die beispielhafte Aufsplittungnoch einmal an Hand eines Bildes im Format JPEG. Wie zu erkennen, besteht das Bild ausmehreren "Contents". Diese wiederum vereinen eine Vielzahl an Pixeln (siehe"Gesplittetes JPEG" in der Abbildung). Diese Bildaten in Verbindung mit dem"JPEG-Header" bilden den gesamten Content. Ein Datenblock besteht dann wie obenbeschrieben und im Bild \ref{fig:beispielJPG} (rechter Teil) zu sehen aus diesemContent und dem dazugehörigen Datenblockheader.\begin{figure}[H]	\centering	\includegraphics[width=\textwidth]{beispielMessage.png}	\caption{muh}	\label{fig:beispielJPG}\end{figure}Neben der Strukturierung und des Aufbaus der Nachricht selbst ist diePriorisierung einzelner Datenblöcke sehr wichtig. Diese gibt an in welcherReihenfolge die Nachrichten versendet werden. Die Priorisierung erfolgt hierbeigrundlegend in zwei Schritten, wie die Abbildung \ref{fig:priorisierungen}zeigt.Zunächst erfolgt eine Vorpriorisierung. Dabei werden relevante Bereicheselektiert und mit einem Relevanzwert eingestuft. DieDatei wird daraufhin in einzelne Datenblöcke zerlegt (siehe Abbildung\ref{fig:priorisierungen} rechts). Diese erhalten abhängig der Wichtigkeit einenPrioritätswert. Dabei wird ein Verhältnis zwischen dem Datenblock und dem darinenthaltenem Inhalt berechnet. Nach der Priorisierung erfolgt eine Einsortierungder Datenblöcke unter Berücksichtigung des Prioritätswertes in die Queue.\begin{figure}[H]	\centering	\includegraphics[width=\textwidth]{Priorisierung.png}	\caption{Datenaufschlüsselung der Nachricht}	\label{fig:priorisierungen}\end{figure}\todo{relevance value (flag)?? was das}