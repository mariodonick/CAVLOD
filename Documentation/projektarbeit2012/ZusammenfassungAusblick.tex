% Zusammenfassung

Für die interplanetare Kommunikation stehen besondere Aspekte, wie Latenz,
Bandbreite oder der lokale Speicher im Vordergrund. Dazu ist ein besonderes
Kommunikationsprotokoll notwendig. Für dieses Protokoll existiert
bereits ein Konzept \cite{Daher}, welches im Rahmen dieser Arbeit
teilweise verfeinert, implementiert und bewertet wurde.

Das Kapitel \ref{cap:grundlagen} und \ref{cap:standDerTechnik} beschäftigte sich
mit den momentanen Stand der Technik sowie den Grundlagen zur Einordnung der
Thematik. Dabei wurde eine Übersicht gegeben, welche die Bedeutung und
Auswirkung eines geringen Zeitslots für die Kommunikation mit dem Mars
verdeutlicht und wie wichtig eine genaue Ermittlung der Zeitdifferenzen zwischen
Mars und Erde ist.

In Kapitel \ref{cap:konzept} wurden mehrere Konzepte für die CROP vorgestellt,
miteinander verglichen und bewertet, die ein Verpacken unterschiedlicher
Datenformate ermöglichen. Neben dem eigentlichen Konzept war die Überlegung der
Handhabung von Verbindungsabbrüchen und Systemabstürzen ein wichtiger
Bestandteil der Arbeit. Dazu wurde unter anderem ein Storemanager entwickelt,
der vor dem Einsortieren in die priorisierende Datenstruktur ein Backup selbiger
durchführt. Somit ist nach einem Neustart ein Wiederherstellen der Datenblöcke
möglich. Schlussendlich wurden die für die Implementierung genutzten
Schnittstellen vorgestellt.

Der eigentliche softwaretechnische Aufbau und die Implementierung wurden in
Kapitel \ref{cap:implementierung} detailliert beschrieben. Weiterhin wurde eine
Kommunikationsumgebung in Form eines ChatGui entwickelt. Unter Verwendung des ROTP
können hier Prioritäten vom Benutzer selbst festgelegt und vom CROP verarbeitet
werden. Damit steht ein Beispiel-Tool zur Verfügung, mit dessen Hilfe sich
unter anderem die Effizienz von M$2$M-Kommunikation des CROP-Protokolls testen
lassen.

Abschließend wurde das Protokoll hinsichtlich Overhead, Laufzeit und
Speicherbedarf analysiert und ausgewertet (Kapitel \ref{cap:protokollAnalyse}).
Dabei kamen zwei verschiedene Compilereinstellungen zum Einsatz, die entweder
die Größe des Quellcodes oder die Laufzeit des Programms beeinflussen. Die
Ergebnisse der Analyse zeigten wie wichtig eine sinnvolle Priorisierung durch
die CROP ist und wie stark der Overhead und die Laufzeit von dieser abhängen.

% Ausblick
Das in dieser Arbeit umgesetzte Protokoll bietet eine solide
Grundlage zur relevanzorientierten Übertragung. Jedoch besteht noch Raum
für Erweiterungen und Optimierungen.

So ist z.B. eine Optimierung der implementierten Algorithmen sinnvoll.
Der erste Anhaltspunkt ist das Submodul \Code{StoreManager}.
Die Zugriffe auf ein Speichermedium während des kontinuierlichen Speicherns und
Ladens der Daten sind sehr langsam und bremsen das gesamte Modul. Eine
Möglichkeit, dies zu verbessern, wäre, das Modul in einem extra Prozess
auszuf{\"u}hren. Dann wären die Zugriffe unabhängig vom eigentlichen
Programmablauf. Ein weiterer Ansatzpunkt ist die Datenstruktur
\Code{SmartPrioritizedQueue}. Für diese muss eine effiziente Möglichkeit
gefunden werden, Datenblöcke schnell einzusortieren, zu löschen und Bl{\"o}cke
bestimmter Größe zu finden.
Die angedachte Kompressionseinstellung aus Kapitel \ref{sec:ProtokolDesign}
findet beispielsweise im \Code{StoreManager} schon Berücksichtigung, wurde aber
noch nicht vollständig implementiert. Dadurch kann in Zukunft für viele kleine
Datenblöcke weiterer Overhead eingespart werden.

Das Protokoll ist aufgrund seiner Flexibilität auf eine Vielzahl an Datentypen
anwendbar. Die Handhabung vieler Daten eines Datentyps zur selben Zeit kann
in Form von parallel ablaufenden Prozessen zur Geschwindigkeitsoptimierung
beitragen. Um andere Datentypen im Protokoll zu verwenden, sollte eine
Schnittstelle zum Laden von Plugins implementiert werden. Damit besteht dann die
Möglichkeit, dem Protokoll Algorithmen hinzuzufügen, wodurch
übliche Datenformate wie docx oder bmp verarbeitet werden können.

Das ebenfalls im Rahmen dieser Arbeit entwickelte ChatGui in Kapitel
\ref{cap:chatGui} hinsichtlich des Zusammenführens der einzelnen Textfragmente
zu optimiert. Sinnvoll wäre hier eine Anzeige über die ablaufende Zeitdauer,
nach welcher ein versendetes Paket den Empfänger erreicht.

Um das entwickelte Modul in Serverumgebungen zu integrieren, muss ein Programm
entwickelt werden, welches in der Lage ist, dieses als Webservice zu starten.
Dadurch können schon bestehende Benutzeroberflächen das Protokoll nutzen.
